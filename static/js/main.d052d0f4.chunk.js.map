{"version":3,"sources":["Components/SearchForm.js","Components/Nav.js","Components/Photo.js","Components/NotFound.js","Components/PhotoList.js","Components/Error.js","config.js","App.js","serviceWorker.js","index.js"],"names":["SearchForm","state","searchText","onSearchChange","e","setState","target","value","handleSubmit","preventDefault","props","onSearch","query","history","push","currentTarget","reset","className","onSubmit","this","type","onChange","name","placeholder","ref","input","id","Component","withRouter","Nav","to","Photo","url","data","server","secret","src","alt","NotFound","PhotoList","photos","results","length","map","photo","index","key","Error","apiKey","App","loading","landscapes","forests","beaches","performSearch","axios","get","then","response","catch","error","console","log","basename","exact","path","render","component","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","message"],"mappings":"+TAIMA,G,kNAEFC,MAAQ,CACJC,WAAY,I,EAGhBC,eAAiB,SAACC,GACd,EAAKC,SAAS,CAAEH,WAAYE,EAAEE,OAAOC,S,EAGzCC,aAAe,SAACJ,GACZA,EAAEK,iBACF,EAAKC,MAAMC,SAAS,EAAKC,MAAML,OAC/B,EAAKG,MAAMG,QAAQC,KAAnB,kBAAmC,EAAKF,MAAML,QAC9CH,EAAEW,cAAcC,S,uDAGX,IAAD,OACJ,OACI,0BAAMC,UAAU,cAAcC,SAAUC,KAAKX,cACzC,2BAAOY,KAAK,SACJC,SAAUF,KAAKhB,eACfmB,KAAK,SACLC,YAAY,mBACZC,IAAM,SAACC,GAAD,OAAW,EAAKb,MAAQa,KACtC,4BAAQL,KAAK,SAASM,GAAG,SAAST,UAAU,iBAA5C,e,GAzBSU,cA+BVC,cAAW5B,GClBX6B,EAdH,WACR,OACI,yBAAKZ,UAAU,YACX,2CACA,4BACI,4BAAI,kBAAC,IAAD,CAASa,GAAG,eAAZ,eACJ,4BAAI,kBAAC,IAAD,CAASA,GAAG,YAAZ,YACJ,4BAAI,kBAAC,IAAD,CAASA,GAAG,YAAZ,eCILC,EAXD,SAACrB,GAEX,IAAIsB,EAAG,wCAAoCtB,EAAMuB,KAAKC,OAA/C,YAAyDxB,EAAMuB,KAAKP,GAApE,YAA0EhB,EAAMuB,KAAKE,OAArF,QAEP,OACI,4BACI,yBAAKC,IAAKJ,EAAKK,IAAI,OCEhBC,EATE,WACb,OACI,yBAAKrB,UAAU,aACX,iDACA,0FCqBGsB,E,uKApBP,IACIC,EADEC,EAAUtB,KAAKT,MAAMuB,KAS3B,OALIO,EADAC,EAAQC,OAAS,EACRD,EAAQE,KAAI,SAACC,EAAOC,GAAR,OAAkB,kBAAC,EAAD,CAAOZ,KAAMQ,EAAQI,GAAQC,IAAKD,OAEhE,kBAAC,EAAD,MAIT,yBAAK5B,UAAU,mBACX,uCACA,4BACKuB,Q,GAhBGb,aCOToB,EATD,WACV,OACI,6BACI,qDACA,6GCJGC,EAFA,mCC6FAC,E,4MA9EbhD,MAAQ,CACJiD,SAAS,EACTV,OAAQ,GACRW,WAAY,GACZC,QAAS,GACTC,QAAS,I,EAUbC,cAAgB,WAA2B,IAA1B1C,EAAyB,uDAAjB,aACvB,EAAKP,SAAS,CAAE6C,SAAQ,IACxBK,IAAMC,IAAN,oFAAuFR,EAAvF,iBAAsGpC,EAAtG,8CACG6C,MAAK,SAAAC,GAES,eAAV9C,EACD,EAAKP,SAAS,CACZ8C,WAAYO,EAASzB,KAAKO,OAAOI,MACjCM,SAAS,IAGQ,YAAVtC,EACT,EAAKP,SAAS,CACZ+C,QAASM,EAASzB,KAAKO,OAAOI,MAC9BM,SAAS,IAGQ,YAAVtC,EACT,EAAKP,SAAS,CACZgD,QAASK,EAASzB,KAAKO,OAAOI,MAC9BM,SAAS,IAIX,EAAK7C,SAAS,CACZmC,OAAQkB,EAASzB,KAAKO,OAAOI,MAC7BM,SAAS,OAIdS,OAAM,SAAAC,GACLC,QAAQC,IAAI,iCAAkCF,O,kEArClDzC,KAAKmC,gBACLnC,KAAKmC,cAAc,WACnBnC,KAAKmC,cAAc,a,+BAuCZ,IAAD,OACN,OACE,kBAAC,IAAD,CAAeS,SAAS,yBACtB,6BACE,wDACA,kBAAC,EAAD,CAAYpD,SAAUQ,KAAKmC,gBAC3B,kBAAC,EAAD,MAEGnC,KAAKlB,MAAMiD,QACV,yCACA,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAOc,OAAK,EAACC,KAAK,IAAIC,OAAS,kBAAM,kBAAC,IAAD,CAAUpC,GAAI,mBACnD,kBAAC,IAAD,CAAOmC,KAAK,cAAcC,OAAS,kBAAM,kBAAC,EAAD,CAAWjC,KAAM,EAAKhC,MAAMkD,gBACrE,kBAAC,IAAD,CAAOc,KAAK,WAAWC,OAAS,kBAAM,kBAAC,EAAD,CAAWjC,KAAM,EAAKhC,MAAMmD,aAClE,kBAAC,IAAD,CAAOa,KAAK,WAAWC,OAAS,kBAAM,kBAAC,EAAD,CAAWjC,KAAM,EAAKhC,MAAMoD,aAClE,kBAAC,IAAD,CAAOY,KAAK,qBAAqBC,OAAS,kBAAM,kBAAC,IAAD,CAAUpC,GAAI,mBAC9D,kBAAC,IAAD,CAAOmC,KAAK,kBAAkBC,OAAS,kBAAM,kBAAC,IAAD,CAAUpC,GAAI,gBAC3D,kBAAC,IAAD,CAAOmC,KAAK,kBAAkBC,OAAS,kBAAM,kBAAC,IAAD,CAAUpC,GAAI,gBAC3D,kBAAC,IAAD,CAAOmC,KAAK,iBAAiBC,OAAS,kBAAM,kBAAC,EAAD,CAAWjC,KAAM,EAAKhC,MAAMuC,YACxE,kBAAC,IAAD,CAAO2B,UAAWpB,W,GAtEhBpB,aCFEyC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASP,OACP,kBAAC,IAAMQ,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBtB,MAAK,SAAAuB,GACJA,EAAaC,gBAEdtB,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAMsB,c","file":"static/js/main.d052d0f4.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport { withRouter } from 'react-router-dom';\n\n\nclass SearchForm extends Component {\n    \n    state = {\n        searchText: ''\n    };\n\n    onSearchChange = (e) => {\n        this.setState({ searchText: e.target.value });\n    }\n\n    handleSubmit = (e) => {\n        e.preventDefault();\n        this.props.onSearch(this.query.value);\n        this.props.history.push(`/search/${this.query.value}`)\n        e.currentTarget.reset();\n    }\n\n    render(){\n        return(\n            <form className=\"search-form\" onSubmit={this.handleSubmit}>\n                <input type=\"search\"\n                        onChange={this.onSearchChange}\n                        name=\"search\"\n                        placeholder=\"Search flikr....\"\n                        ref={ (input) => this.query = input} />\n                <button type=\"submit\" id=\"submit\" className=\"search-button\">Search</button>\n            </form>\n        );\n    }\n}\n\nexport default withRouter(SearchForm);","import React from 'react';\nimport { NavLink } from 'react-router-dom';\n\nconst Nav = () => {\n    return (\n        <div className=\"main-nav\">\n            <h4>Quick Links</h4>\n            <ul>\n                <li><NavLink to=\"/landscapes\">Landscapes</NavLink></li>\n                <li><NavLink to=\"/forests\">Forests</NavLink></li>\n                <li><NavLink to=\"/beaches\">Beaches</NavLink></li>\n            </ul>\n        </div>\n\n    )\n}\n\nexport default Nav;","import React from 'react';\nimport '../index.css';\n\nconst Photo = (props) => {\n    \n    let url = `https://live.staticflickr.com/${props.data.server}/${props.data.id}_${props.data.secret}.jpg`;\n\n    return(\n        <li>\n            <img src={url} alt=\"\" /> \n        </li>\n    );\n};\n\nexport default Photo;","import React from 'react';\n\nconst NotFound = () => {\n    return (\n        <div className=\"not-found\">\n            <h3>No results found.</h3>\n            <p>That search did not return any results. Please try again.</p>\n        </div>\n    )\n}\n\nexport default NotFound;","import React, { Component } from 'react';\nimport Photo from './Photo';\nimport NotFound from './NotFound';\n\nclass PhotoList extends Component{\n\n    render(){\n        const results = this.props.data;\n        let photos;\n\n        if (results.length > 0) {\n            photos = results.map((photo, index) => <Photo data={results[index]} key={index} />)\n        } else {\n            photos = <NotFound />\n        }\n\n        return (\n            <div className=\"photo-container\">\n                <h2>Results</h2>\n                <ul>\n                    {photos}\n                </ul>\n            </div>\n        )\n    }\n}\n\nexport default PhotoList;","import React from 'react';\n\nconst Error = () => {\n    return (\n        <div>\n            <h3>Error: Path not found</h3>\n            <p>Try a new search or click one of the links above to go back to a known path.</p>\n        </div>\n    )\n}\n\nexport default Error;","const apiKey = '79fb7cac0887f2c4ccc82318a5cab5aa';\n// const secret = 'c7a82ed38163a0c3';\nexport default apiKey;","import React, { Component } from 'react';\nimport { BrowserRouter, Route, Switch, Redirect } from 'react-router-dom';\nimport axios from 'axios';\n\n//App Components\nimport './App.css';\nimport SearchForm from './Components/SearchForm';\nimport Nav from './Components/Nav';\nimport PhotoList from './Components/PhotoList';\nimport Error from './Components/Error';\n\nimport apiKey from './config';\n\n\nclass App extends Component {\n  state = {\n      loading: true,\n      photos: [],\n      landscapes: [],\n      forests: [],\n      beaches: [],\n    };\n\n  componentDidMount(){\n    this.performSearch()\n    this.performSearch('forests')\n    this.performSearch('beaches')\n  }\n\n  //Search handling method\n  performSearch = (query = 'landscapes') => {\n    this.setState({ loading:true });\n    axios.get(`https://www.flickr.com/services/rest/?method=flickr.photos.search&api_key=${apiKey}&tags=${query}&per_page=24&format=json&nojsoncallback=1`)\n      .then(response => {\n\n        if(query === 'landscapes'){\n          this.setState({\n            landscapes: response.data.photos.photo,\n            loading: false\n          });\n\n        } else if (query === 'forests'){\n          this.setState({\n            forests: response.data.photos.photo,\n            loading: false\n          })\n\n        } else if (query === 'beaches'){\n          this.setState({\n            beaches: response.data.photos.photo,\n            loading: false\n          })\n\n        } else {\n          this.setState({\n            photos: response.data.photos.photo,\n            loading: false\n          })\n        }\n      })\n      .catch(error => {\n        console.log('Error with axios fetching data', error)\n      })\n  }\n  \n  render(){\n    return (\n      <BrowserRouter basename=\"/react-gallery-app-V2\">\n        <div>\n          <h1>Jeff's React Gallery App</h1>\n          <SearchForm onSearch={this.performSearch} />\n          <Nav />\n          {\n            (this.state.loading)\n            ? <p>Loading...</p>\n            : <Switch>\n                <Route exact path=\"/\" render={ () => <Redirect to =\"/landscapes\" /> } />\n                <Route path=\"/landscapes\" render={ () => <PhotoList data={this.state.landscapes}/> } />\n                <Route path=\"/forests\" render={ () => <PhotoList data={this.state.forests}/> } />\n                <Route path=\"/beaches\" render={ () => <PhotoList data={this.state.beaches}/> } />\n                <Route path=\"/search/landscapes\" render={ () => <Redirect to =\"/landscapes\" /> } />\n                <Route path=\"/search/forests\" render={ () => <Redirect to =\"/forests\" /> } />\n                <Route path=\"/search/beaches\" render={ () => <Redirect to =\"/beaches\" /> } />\n                <Route path=\"/search/:query\" render={ () => <PhotoList data={this.state.photos}/> } />\n                <Route component={Error}/>\n              </Switch>\n          }\n        </div>\n      </BrowserRouter>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}